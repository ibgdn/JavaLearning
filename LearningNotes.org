* how2j
** JAVA 基础
*** 类和对象
**** 传参
***** 引用与=
如果一个变量是基本类型，比如 int hp = 50; 我们就直接管hp叫变量，=表示赋值的意思。
如果一个变量是类类型，比如 Hero h = new Hero(); 我们就管h叫做引用。=不再是赋值的意思，=表示指向的意思，比如 Hero h = new Hero(); 这句话的意思是，引用h，指向一个Hero对象。
**** 访问修饰符
***** 那么什么情况该用什么修饰符呢？
使用修饰符的情况：
1. 属性通常使用private封装起来
2. 方法一般使用public用于被调用
3. 会被子类继承的方法，通常使用protected
4. package用的不多，一般新手会用package,因为还不知道有修饰符这个东西

当一个属性被static修饰的时候，就叫做类属性，又叫做静态属性。
当一个属性被声明成类属性，那么所有的对象，都共享一个值。
方法设计：
如果方法里访问了对象属性，那么这个方法，就必须设计为对象方法；如果一个方法，没有调用任何对象属性，那么就可以考虑设计为类方法。

**** 单例模式
***** 什么时候使用恶汉式，什么时候使用懒汉式
单例模式选择：
饿汉式是立即加载的方式，无论是否会用到这个对象，都会加载。如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。
懒汉式，是延迟加载的方式，只有使用的时候才会加载。 并且有线程安全的考量(鉴于同学们学习的进度，暂时不对线程的章节做展开)。使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。
***** 单例模式三要素
什么是单例模式？
回答的时候，要答到三元素：1. 构造方法私有化 2. 静态属性指向实例 3. public static的 getInstance方法，返回第二步的静态属性
*** 接口与继承
**** 抽象类
***** 抽象类和接口的区别
区别1：子类只能继承一个抽象类，不能继承多个；子类可以实现多个接口
区别2：抽象类可以定义 public,protected,package,private、静态和非静态属性、final和非final属性；但是接口中声明的属性，只能是 public、静态、final的，即便没有显示的声明
注: 抽象类和接口都可以有实体方法。 接口中的实体方法，叫做默认方法
**** JAVA 内部类详解
***** 在匿名类中使用外部的局部变量
在匿名内部类中使用外部的局部变量，外部的局部变量必须修饰为final，jdk8中如果不声明为 final 会自动添加。
*** 数字与字符串
**** StringBuffer
***** 长度容量
为什么StringBuffer可以变长？
和String内部是一个字符数组一样，StringBuffer也维护了一个字符数组。 但是，这个字符数组，留有冗余长度
比如说new StringBuffer("the")，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，看上去 数组长度就变长了。


** JAVA 中级
*** I/O
**** 关闭流的方式
***** 在 finally 中关闭
关闭流的方式：
1. 首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally.
2. 在finally关闭之前，要先判断该引用是否为空
3. 关闭的时候，需要再一次进行try catch处理
**** 对象流
对象流指的是可以直接把一个对象以流的形式传输给其他的介质，比如硬盘。一个对象以流的形式进行传输，叫做序列化。 该对象所对应的类，必须是实现Serializable接口。
***** 序列化一个对象
//表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号
private static final long serialVersionUID = 1L;
*** 集合框架
**** 与数组的区别
***** ArrayList 存放对象
为了解决数组的局限性，引入容器类的概念。 最常见的容器类就是 ArrayList 容器的容量"capacity"会随着对象的增加，自动增长只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。
**** ArrayList vs LinkedList
***** ArrayList 和 LinkedList 的区别
ArrayList 插入，删除数据慢；LinkedList， 插入，删除数据快
ArrayList是顺序结构，所以定位很快，指哪找哪。 就像电影院位置一样，有了电影票，一下就找到位置了。LinkedList 是链表结构，就像手里的一串佛珠，要找出第99个佛珠，必须得一个一个的数过去，所以定位慢。
**** HashMap vs Hashtable
***** HashMap 和 Hastable 的区别
HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式
区别1：HashMap可以存放 null；Hashtable不能存放null
区别2：HashMap不是线程安全的类；Hashtable是线程安全的类
*** 泛型
**** 通配符
***** 总结
泛型的使用：
如果希望只取出，不插入，就使用 ? extends Hero
如果希望只插入，不取出，就使用 ? super Hero
如果希望，又能插入，又能取出，就不要用通配符？
*** Lambda
**** Hello Lambda
***** 从匿名类演变成 Lambda 表达式
Lambda表达式可以看成是匿名类一点点演变过来
1. 匿名类的正常写法
HeroChecker c1 = new HeroChecker() {
    public boolean test(Hero h) {
    return (h.hp>100 && h.damage<50);
    }
};
2. 把外面的壳子去掉
只保留方法参数和方法体
参数和方法体之间加上符号 ->
HeroChecker c2 = (Hero h) ->{
        return h.hp>100 && h.damage<50;
};
3. 把return和{}去掉
HeroChecker c3 = (Hero h) ->h.hp>100 && h.damage<50;
4. 把 参数类型和圆括号去掉(只有一个参数的时候，才可以去掉圆括号)
HeroChecker c4 = h ->h.hp>100 && h.damage<50;
5. 把c4作为参数传递进去
filter(heros,c4);
6. 直接把表达式传递进去
filter(heros, h -> h.hp > 100 && h.damage < 50);
***** 匿名方法
Lambda 其实就是匿名方法，这是一种把方法作为参数进行传递的编程思想。Java会在背后，悄悄的，把这些都还原成匿名类方式。
***** Lambda 的弊端
Lambda表达式虽然带来了代码的简洁，但是也有其局限性。
1. 可读性差，与啰嗦但是清晰的匿名类代码比起来，Lambda表达式一旦变得比较长，就难以理解
2. 不便于调试，很难在Lambda表达式中增加调试信息，比如日志
3. 版本支持，Lambda表达式在JDK8版本中才开始支持，如果系统使用的是以前的版本，考虑系统的稳定性等原因，而不愿意升级，那么就无法使用。
**** 聚合操作
***** 管道源
把Collection切换成管道源很简单，调用stream()就行了。
heros.stream()
但是数组却没有stream()方法，需要使用
Arrays.stream(hs) 或者 Stream.of(hs)
***** 中间操作
每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历。
中间操作比较多，主要分两类：对元素进行筛选 和 转换为其他形式的流
对元素进行筛选：
filter 匹配
distinct 去除重复(根据equals判断)
sorted 自然排序
sorted(Comparator<T>) 指定排序
limit 保留
skip 忽略
转换为其他形式的流
mapToDouble 转换为double的流
map 转换为任意类型的流
***** 结束操作
当进行结束操作后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach，什么都不返回。
结束操作才真正进行遍历行为，前面的中间操作也在这个时候，才真正的执行。
常见结束操作如下：
forEach() 遍历每个元素
toArray() 转换为数组
min(Comparator<T>) 取最小的元素
max(Comparator<T>) 取最大的元素
count() 总数
findFirst() 第一个元素
*** 多线程
**** 同步
***** 分析同步问题产生的原因
1. 假设增加线程先进入，得到的hp是10000
2. 进行增加运算
3. 正在做增加运算的时候，还没有来得及修改hp的值，减少线程来了
4. 减少线程得到的hp的值也是10000
5. 减少线程进行减少运算
6. 增加线程运算结束，得到值10001，并把这个值赋予hp
7. 减少线程也运算结束，得到值9999，并把这个值赋予hp
hp，最后的值就是9999
虽然经历了两个线程各自增减了一次，本来期望还是原值10000，但是却得到了一个9999
这个时候的值9999是一个错误的值，在业务上又叫做脏数据。
***** 解决思路
总体解决思路是： 在增加线程访问hp期间，其他线程不可以访问hp
1. 增加线程获取到hp的值，并进行运算
2. 在运算期间，减少线程试图来获取hp的值，但是不被允许
3. 增加线程运算结束，并成功修改hp的值为10001
4. 减少线程，在增加线程做完后，才能访问hp的值，即10001
5. 减少线程运算，并得到新的值10000
***** 使用hero对象作为同步对象
pojo 代码段：
    //回血
    public void recover(){
        hp=hp+1;
    }
    //掉血
    public void hurt(){
        //使用this作为同步对象
        synchronized (this) {
            hp=hp-1;
        }
    }
test 代码段：
    //使用gareen作为synchronized
    synchronized (gareen) {
        gareen.recover();
    }
    ……
    // 效果相似的代码段
    //使用gareen作为synchronized
    //在方法hurt中有synchronized(this)
    gareen.hurt();
*****  在方法前，加上修饰符 synchronized
pojo 代码段：
    //回血
    //直接在方法前加上修饰符synchronized
    //其所对应的同步对象，就是this
    //和hurt方法达到的效果一样
    public synchronized void recover(){
        hp=hp+1;
    }
    //掉血
    public void hurt(){
        //使用this作为同步对象
        synchronized (this) {
            hp=hp-1;
        }
    }
test 代码段：
    //recover自带synchronized
    gareen.recover();
    //hurt自带synchronized
    gareen.hurt();
***** 线程安全的类
如果一个类，其方法都是有synchronized修饰的，那么该类就叫做线程安全的类。
同一时间，只有一个线程能够进入 这种类的一个实例 的去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)。
比如StringBuffer和StringBuilder的区别：
StringBuffer的方法都是有synchronized修饰的，StringBuffer就叫做线程安全的类，而StringBuilder就不是线程安全的类。
**** 线程安全的类
*****  把非线程安全的集合转换为线程安全
ArrayList是非线程安全的，换句话说，多个线程可以同时进入一个ArrayList对象的add方法。
借助Collections.synchronizedList，可以把ArrayList转换为线程安全的List。
与此类似的，还有HashSet,LinkedList,HashMap等等非线程安全的类，都通过工具类Collections转换为线程安全的。
代码段：
    public static void main(String[] args) {
        List<Integer> list1 = new ArrayList<>();
        List<Integer> list2 = Collections.synchronizedList(list1);
    }
**** 交互
***** 关于wait、notify和notifyAll
这里需要强调的是，wait方法和notify方法，并不是Thread线程上的方法，它们是Object上的方法。

因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。

wait()的意思是： 让占用了这个同步对象的线程，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。

notify() 的意思是，通知一个等待在这个同步对象上的线程，你可以苏醒过来了，有机会重新占用当前对象了。

notifyAll() 的意思是，通知所有的等待在这个同步对象上的线程，你们可以苏醒过来了，有机会重新占用当前对象了。
**** Lock 对象
*****  使用Lock对象实现同步效果
Lock是一个接口，为了使用一个Lock对象，需要用到

Lock lock = new ReentrantLock();

与 synchronized (someObject) 类似的，lock()方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。
与 synchronized 不同的是，一旦synchronized 块结束，就会自动释放对someObject的占用。 lock却必须调用unlock方法进行手动释放，为了保证释放的执行，往往会把unlock() 放在finally中进行。
*****  trylock方法
synchronized 是不占用到手不罢休的，会一直试图占用下去。
与 synchronized 的钻牛角尖不一样，Lock接口还提供了一个trylock方法。
trylock会在指定时间范围内试图占用，占成功了，就啪啪啪。 如果时间到了，还占用不成功，扭头就走~

注意： 因为使用trylock有可能成功，有可能失败，所以后面unlock释放锁的时候，需要判断是否占用成功了，如果没占用成功也unlock,就会抛出异常。
***** 总结Lock和synchronized的区别
1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。

2. Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。

3. synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。

**** 原子访问
*****  AtomicInteger
JDK6 以后，新增加了一个包java.util.concurrent.atomic，里面有各种原子类，比如AtomicInteger。
而AtomicInteger提供了各种自增，自减等方法，这些方法都是原子性的。 换句话说，自增方法 incrementAndGet 是线程安全的，同一个时间，只有一个线程可以调用这个方法。
*** JDBC
**** MySQL
*****  使用Mysql自带命令行 备份
假定mysql安装在D:/software/MySQL Server 5.1/
那么其bin目录下有一个mysqldump.exe文件
账号是root
密码是admin
备份的数据库名是 test
备份后的文件是 d:\test.sql

"D:/software/MySQL Server 5.1/bin/mysqldump.exe" -uroot   -padmin   -hlocalhost   -P3306   test -r d:\test.sql
***** 使用mysql自带命令
假定mysql安装在D:/software/MySQL Server 5.1/
那么其bin目录下有一个mysql.exe文件
账号是root
密码是admin
还原的数据库名是 test
还原的文件是 d:\test.sql

"D:/software/MySQL Server 5.1/bin/mysql.exe" -u root -padmin test < d:/test.sql
***** 修改 root 账户密码
执行如下命令：
"D:\tools\MYSQL\mysql-5.1.57-win32\bin\mysql.exe" -u root -padmin

注： 我的mysql.exe文件位于D:\tools\MYSQL\mysql-5.1.57-win32\bin，请根据自己的情况，做相应的修改
注： 我的密码是 admin, 请做相应调整。
执行如下命令，即可把root密码修改为admin

set password for root@localhost = password('admin');
**** execute executeUpdate
execute与executeUpdate的相同点：都可以执行增加，删除，修改。
不同1：
execute可以执行查询语句，然后通过getResultSet，把结果集取出来
executeUpdate不能执行查询语句
不同2:
execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等
executeUpdate返回的是int，表示有多少条数据受到了影响
**** 事务
*****  MYSQL 表的类型必须是INNODB才支持事务
在Mysql中，只有当表的类型是INNODB的时候，才支持事务，所以需要把表的类型设置为INNODB,否则无法观察到事务.
修改表的类型为INNODB的SQL：
alter table hero ENGINE  = innodb;
查看表的类型的SQL
show table status from how2java;
不过有个前提，就是当前的MYSQL服务器本身要支持INNODB。
*** 图形界面
**** 事件监听
***** 适配器
MouseAdapter 鼠标监听适配器
一般说来在写监听器的时候，会实现MouseListener。
但是MouseListener里面有很多方法实际上都没有用到，比如mouseReleased ，mousePressed，mouseExited等等。
这个时候就可以使用 鼠标监听适配器，MouseAdapter 只需要重写必要的方法即可。
**** 容器
***** 模态JDialog
当一个对话框被设置为模态的时候，其背后的父窗体，是不能被激活的，除非该对话框被关闭。


** 事件项目
*** 一本糊涂账
**** 基础
***** 开发流程
****** 表结构设计
在开始整个软件开发之前，一定是事先进行表结构设计。

把表有哪些字段搞清楚，表与表之间的关系理顺。

同时还要校验这样的表结构，是否能够支撑功能上的需要。

比如在消费一览中需要的各种数据，应该以什么样的方式去设计这些表，才能够支撑页面上的数据显示。

在专门的表结构设计章节里，会把每张表列出来，每个字段的意义，类型，限制。 表与表之间的关系，一对多关系，多对一关系如何确定与设计。主键约束，外键约束等等信息。
****** 原型设计
在开始正式的功能开发之前，要进行原型设计。

什么是原型设计呢？ 简单说，就是先把界面做出来。 界面上的数据，都是假数据，并不是从数据库中读取的真实数据。

为什么要这么做呢？ 有了界面，才直观，你才会更有感觉，也才能更清楚各个功能之间怎么实现。 更重要的是，有了界面，才能更有效的和客户沟通，哪些功能需要修改，哪些功能可以删减。

本项目学习中，原型分两个部分来讲解，一个是原型-基础，一个是原型-界面类

在原型-基础章节，会从最粗简的方式开始，然后演示如何从粗陋的直接new JFrame逐步演化到面板分离，监听器分离，模型分离，并且讲解为什么要这样做和这样做带来的好处。，并重构出各种工具类，供后续界面设计重用。

在原型-界面类章节，使用原型-基础中的设计思想，运用其中的工具类，把本项目设计到的各种界面原型，一一开发出来。
****** 实体类与DAO的设计
在开始功能开发之前，首先要设计实体类与DAO。相关的数据库操作，都经由DAO来完成。
****** 功能开发
接下来才开始功能开发。

首先是确定多层结构，基于事件驱动，规划DAO层，Service层。 并且在开发过程中，演示重构并解释重构的理由和好处。

接着是开发顺序。 各个模块之间是互相依赖的，有的需要先行开发，有的模块必须建立在其他模块的基础上才可以执行。

最后，引用第三方的包。 比如动态生成chart图片，演示如何使用这些API。
**** 表结构设计
***** 数据库与表
****** 创建数据库
数据库名定为hutubill，在程序中的JDBC相关代码，都需要连接这个数据库名 hutubill
create database hutubill;
****** 确定需要哪些表
根据业务上的需要，一共要3个表
1. 配置表信息 config
用于保存每月预算和Mysql的安装路径( 用于备份还原用)
2. 消费分类表 category
用于保存消费分类，比如餐饮，交通，住宿
3. 消费记录表 record
用于存放每一笔的消费记录，并且会用到消费分类
****** 配置信息表 config
 配置信息表 config有如下字段
id 主键，每个表都有一个主键 类型是 int
key_ 配置信息按照键值对的形式出现 ，类型是varchar(255)
value配置信息的值, 类型是 varchar(255)

注:
1. 键值对
进一步解释一下键值对，比如要存放每个月的预算，则需要在在config表中增加一条记录，key="budget" value="500"，就表示预算是500.

2. varchar(255) 表示变长字符，如果实际存放只有30个字符，那么在数据库中只占用30的空间，最多占用255

3. key 是关键字，不适合用于作为字段名，所以在key后面加了一个下划线 key_ 就不会有任何问题了，识别性一样很好，一眼就知道这个字段是干什么用的

4. ENGINE=InnoDB MySQL有多种存储引擎，MyISAM和InnoDB是其中常用的两种， 他们之间的区别很多，如果要展开讲，就需要专门的章节了。 这里使用ENGINE=InnoDB 是因为后续要使用的外键约束只有在InnoDB中才生效。

5. DEFAULT CHARSET=utf8; 表示该表按照UTF-8的编码存放中文
CREATE TABLE config (
  id int ,
  key_ varchar(255) ,
  value varchar(255)
)  ENGINE=InnoDB  DEFAULT CHARSET=utf8;
****** 消费分类表 category
消费分类表 category 有如下字段
id 主键，每个表都有一个主键 类型是 int
name分类的名称，类型是varchar(255)
CREATE TABLE category (
  id int,
  name varchar(255)
)   ENGINE=InnoDB DEFAULT CHARSET=utf8;
****** 消费记录表 record
 消费记录表 record 有如下字段：
id 主键，每个表都有一个主键 类型是 int
spend 本次花费，类型是int
cid 对应的消费分类表的中记录的id, 类型是int
comment 备注，比如分类是娱乐，但是你希望记录更详细的内容，啪啪啪，那么就存放在这里。
date 日期，本次记录发生的时间。
CREATE TABLE record (
  id int,
  spend int,
  cid int,
  comment varchar(255) ,
  date Date
)   ENGINE=InnoDB DEFAULT CHARSET=utf8;
****** 约束
分析这一条增加约束的SQL语句：
alter table category 表示修改表category
add constraint 增加约束
pk_category_id 约束名称 pk 是primary key的缩写，category是表名, id表示约束加在id字段上。约束名称是可以自己定义的，你可以写成abc，但是尽量使用好的命名，使得一眼就能够看出来这个约束是什么意思。 能够降低维护成本。
primary key 约束类型是主键约束
(id) 表示约束加在id字段上
--主键约束
alter table category add constraint pk_category_id primary key (id);
alter table record add constraint pk_record_id primary key (id);
alter table config add constraint pk_config_id primary key (id);

分析这条SQL语句：
alter table category 表示修改表category
change id 表示修改字段 id
id int auto_increment; 修改后的id是 int类型，并且是auto_increment(修改之前仅仅是int类型，没有auto_increment)
--自增长
alter table category change id id int auto_increment;
alter table record change id id int auto_increment;
alter table config change id id int auto_increment;

以下是增加外键约束的SQL：
alter table record 修改表record
add constraint 增加约束
fk_record_category 约束名称fk_record_category,fk是foreign key的缩写，record_category表示是从record表指向category表的约束。 与主键一样，约束名称也是可以自己定义的，比如写成abc. 不过依然建议使用可读性好的命名方式。
foreign key 约束类型，外键
(cid) references category(id) 本表record的字段 cid 指向category表的字段id
--外键约束
alter table record add constraint fk_record_category foreign key (cid) references category(id)
****** 整合
create database hutubill;

CREATE TABLE config (
  id int AUTO_INCREMENT,
  key_ varchar(255) ,
  value varchar(255) ,
  PRIMARY KEY (id)
)  DEFAULT CHARSET=utf8;

CREATE TABLE category (
  id int AUTO_INCREMENT,
  name varchar(255) ,
  PRIMARY KEY (id)
)  DEFAULT CHARSET=utf8;

CREATE TABLE record (
  id int AUTO_INCREMENT,
  spend int,
  cid int,
  comment varchar(255) ,
  date Date,
  PRIMARY KEY (id),
  CONSTRAINT `fk_record_category` FOREIGN KEY (`cid`) REFERENCES `category` (`id`)
)  DEFAULT CHARSET=utf8;

**** 原型-基础
***** 界面包的规划
由于预见到了直接在main中编写JFrame带来的代码的冗长和难以维护性的增加。 我们需要把界面相关的类，独立出来，并且放在不同的包下面进行管理和维护。

首先是Frame
整个程序只有一个主Frame，所以把这个类规划到包gui.frame下

然后是Panel
JFrame本身有一个Panel，然后每一个功能模块都有一个Panel，所以把这些Panel规划到gui.panel下面去

接着是Listener
把所有的监听器，都做成独立的类，实现ActionListener接口，并放在gui.listener包下

最后是Model
Model用于存放数据，在这个项目中会用到TableModel和ComboBoxModel，放在gui.model包下
***** 项目完成后界面相关包的规划截图
把不同的界面相关类，规划在不同的界面包下面

如图MainFrame 主窗体类，规划在gui.frame包下

SpendPanel 消费一览面板类，规划在gui.panel包下
RecordPanel 记一笔面板类，规划在gui.panel包下
等等

ToolBarListener 工具条监听器类，规划在gui.listener包下
BackupListener 备份监听器类，规划在gui.listener包下
等等

CategoryComboBoxModel 分类下拉框Model类，规划在gui.model包下
CategoryTableModel 分类表格Model类，规划在gui.model包下


*** bill 实践
**** 表结构
***** 建表语句 Oracle
drop tablespace bill;
-- 创建.dbf文件，“D:\app\Administrator\oradata\happy”必须完整，.dbf文件自动创建
create tablespace bill
logging
datafile 'D:\app\Administrator\oradata\bill\bill.dbf'
size 32m
autoextend on
next 32m maxsize 2048m
extent management local;

-- 创建用户并指定表空间
create user bill identified by bill
default tablespace bill;
-- temporary tablespace test_temp;

-- 给用户授予权限
grant connect,resource,dba to bill;

drop table config;
CREATE TABLE config (
  id integer ,
  key_ varchar2(255) ,
  value varchar2(255)
);
drop table category;
CREATE TABLE category (
  id integer,
  name varchar2(255)
);
drop table record;
CREATE TABLE record (
  id integer,
  spend number(11,3),
  cid integer,
  comment_ varchar2(255) ,
  date_ Date
);

--添加表注释：
COMMENT ON table config IS '配置表信息';
COMMENT ON table category IS '消费分类表';
COMMENT ON table record IS '消费记录表';

--添加字段注释：
comment on column config.id  is '主键';
comment on column config.key_ is '配置信息按照键值对的形式出现';
comment on column config.value is '配置信息的值';

comment on column category.id  is '主键';
comment on column category.name is '分类的名称';

comment on column record.id  is '主键';
comment on column record.spend is '本次花费';
comment on column record.cid is '对应的消费分类表的中记录的id';
comment on column record.comment_ is '备注';
comment on column record.date_ is '日期';

--主键约束
alter table category add constraint pk_category_id primary key (id);
alter table record add constraint pk_record_id primary key (id);
alter table config add constraint pk_config_id primary key (id);

--自增长
--创建自动增长序列
create sequence config_autoinc
     minvalue 1
     maxvalue 999999999
     start with 1
     increment by 1
     nocache;
create sequence category_autoinc
     minvalue 1
     maxvalue 999999999
     start with 1
     increment by 1
     nocache;
create sequence record_autoinc
     minvalue 1
     maxvalue 999999999
     start with 1
     increment by 1
     nocache;

--创建触发器将序列中的值赋给插入表中对应的行
create or replace trigger insert_config_autoinc
  before insert on config
  for each row
begin
  if (:new.id is null) then
    select config_autoinc.nextval into :new.id from dual;
  end if;
end;

create or replace trigger insert_category_autoinc
  before insert on category
  for each row
begin
  if (:new.id is null) then
    select category_autoinc.nextval into :new.id from dual;
  end if;
end;

create or replace trigger insert_record_autoinc
  before insert on record
  for each row
begin
  if (:new.id is null) then
    select record_autoinc.nextval into :new.id from dual;
  end if;
end;

--外键约束
alter table record add constraint fk_record_category foreign key (cid) references category(id);
***** 建表语句 MySQL
create database billdb;

CREATE TABLE config (
  id int AUTO_INCREMENT,
  key_ varchar(255) ,
  value varchar(255) ,
  PRIMARY KEY (id)
)  DEFAULT CHARSET=utf8;

CREATE TABLE category (
  id int AUTO_INCREMENT,
  name varchar(255) ,
  PRIMARY KEY (id)
)  DEFAULT CHARSET=utf8;

CREATE TABLE record (
  id int AUTO_INCREMENT,
  spend int,
  cid int,
  comment varchar(255) ,
  date Date,
  PRIMARY KEY (id),
  CONSTRAINT `fk_record_category` FOREIGN KEY (`cid`) REFERENCES `category` (`id`)
)  DEFAULT CHARSET=utf8;


**** 原型-基础
***** 界面包的规划
使用 maven 构建项目：
mvn archetype:generate -DgroupId=com.bill -DartifactId=bill -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false


** JAVA 高级

*** 反射机制

**** 获取类对象

***** 什么是类对象
      类对象，就是用于描述类，都有什么属性，什么方法的。

***** 获取类对象
      获取类对象有3种方式：
1. Class.forName("Hero");
2. Hero.class;
3. new Hero().getClass();

在一个JVM中，一种类，只会有一个类对象存在。所以以上三种方式取出来的类对象，都是一样的。

注： 准确的讲是一个ClassLoader下，一种类，只会有一个类对象存在。通常一个JVM下，只会有一个ClassLoader。

***** 访问属性
      为了访问属性，把name修改为public。
      对于private修饰的成员，需要使用setAccessible(true)才能访问和修改。不在此知识点讨论。

***** getField和getDeclaredField的区别
      这两个方法都是用于获取字段。
      getField 只能获取public的，包括从父类继承来的字段。
      getDeclaredField 可以获取本类所有的字段，包括private的，但是不能获取继承来的字段。 (注： 这里只能获取到private的字段，但并不能访问该private字段的值)。

***** 有什么用
      反射非常强大，但是学习了之后，会不知道该如何使用，反而觉得还不如直接调用方法来的直接和方便。
      通常来说，需要在学习了Spring 的依赖注入，反转控制之后，才会对反射有更好的理解，但是刚学到这里的同学，不一定接触了Spring，所以在这里举两个例子，来演示一下反射的一种实际运用。

      使用反射方式，首先准备一个配置文件，就叫做spring.txt吧, 放在src目录下。 里面存放的是类的名称，和要调用的方法名。
      在测试类Test中，首先取出类名称和方法名，然后通过反射去调用这个方法。
      当需要从调用第一个业务方法，切换到调用第二个业务方法的时候，不需要修改一行代码，也不需要重新编译，只需要修改配置文件spring.txt，再运行即可。
      这也是Spring框架的最基本的原理，只是它做的更丰富，安全，健壮。

      spring.txt
      class=reflection.Service1
      method=doService1

      Test.java
      package reflection;

      import java.io.File;
      import java.io.FileInputStream;
      import java.lang.reflect.Constructor;
      import java.lang.reflect.Method;
      import java.util.Properties;

public class Test {

    @SuppressWarnings({ "rawtypes", "unchecked" })
    public static void main(String[] args) throws Exception {

        //从spring.txt中获取类名称和方法名称
        File springConfigFile = new File("e:\\project\\j2se\\src\\spring.txt");
        Properties springConfig= new Properties();
        springConfig.load(new FileInputStream(springConfigFile));
        String className = (String) springConfig.get("class");
        String methodName = (String) springConfig.get("method");

        //根据类名称创建类对象
        Class clazz = Class.forName(className);
        //根据方面名称，获取方法
        Method m = clazz.getMethod(methodName);
        //获取构造器
        Constructor c = clazz.getConstructor();
        //根据构造器，实例化出对象
        Object service = c.newInstance();
        //调用对象的指定方法
        m.invoke(service);

    }
}

*** 注解

**** 自定义注解

**** 自定义注解@JDBCConfig
     1. 创建注解类型的时候即不使用class也不使用interface,而是使用@interface
        public @interface JDBCConfig
     2. 元注解
        @Target({METHOD,TYPE}) 表示这个注解可以用用在类/接口上，还可以用在方法上
        @Retention(RetentionPolicy.RUNTIME) 表示这是一个运行时注解，即运行起来之后，才获取注解中的相关信息，而不像基本注解如@Override 那种不用运行，在编译时eclipse就可以进行相关工作的编译时注解。
        @Inherited 表示这个注解可以被子类继承
        @Documented 表示当执行javadoc的时候，本注解会生成相关文档
     3. 注解元素，这些注解元素就用于存放注解信息，在解析的时候获取出来
        import static java.lang.annotation.ElementType.METHOD;
        import static java.lang.annotation.ElementType.TYPE;
        import java.lang.annotation.Documented;
        import java.lang.annotation.Inherited;
        import java.lang.annotation.Retention;
        import java.lang.annotation.RetentionPolicy;
        import java.lang.annotation.Target;
        @Target({METHOD,TYPE})
        @Retention(RetentionPolicy.RUNTIME)
        @Inherited
        @Documented
        public @interface JDBCConfig {
          String ip();
          int port() default 3306;
          String database();
          String encoding();
          String loginName();
          String password();
        }
     4. 设置注解信息
        import anno.JDBCConfig;
        @JDBCConfig(ip = "127.0.0.1", database = "test", encoding = "UTF-8", loginName = "root", password = "admin")
        public class DBUtil {
          static {
            try {
              Class.forName("com.mysql.jdbc.Driver");
            } catch (ClassNotFoundException e) {
              e.printStackTrace();
            }
          }
        }
     5. 解析注解信息
        通过反射，获取这个DBUtil这个类上的注解对象
          JDBCConfig config = DBUtil.class.getAnnotation(JDBCConfig.class);
        拿到注解对象之后，通过其方法，获取各个注解元素的值：
          String ip = config.ip();
          int port = config.port();
          String database = config.database();
          String encoding = config.encoding();
          String loginName = config.loginName();
          String password = config.password();
        后续就一样了，根据这些配置信息得到一个数据库连接Connection实例。

        import anno.JDBCConfig;
        @JDBCConfig(ip = "127.0.0.1", database = "test", encoding = "UTF-8", loginName = "root", password = "admin")
        public class DBUtil {
          static {
            try {
              Class.forName("com.mysql.jdbc.Driver");
            } catch (ClassNotFoundException e) {
              e.printStackTrace();
            }
          }

          public static Connection getConnection() throws SQLException, NoSuchMethodException, SecurityException {
            JDBCConfig config = DBUtil.class.getAnnotation(JDBCConfig.class);

            String ip = config.ip();
            int port = config.port();
            String database = config.database();
            String encoding = config.encoding();
            String loginName = config.loginName();
            String password = config.password();

            String url = String.format("jdbc:mysql://%s:%d/%s?characterEncoding=%s", ip, port, database, encoding);
            return DriverManager.getConnection(url, loginName, password);
          }

          public static void main(String[] args) throws NoSuchMethodException, SecurityException, SQLException {
            Connection c = getConnection();
            System.out.println(c);
          }
        }

**** 元注解
     元注解 meta annotation用于注解 自定义注解 的注解。元注解有这么几种：
     @Target
     @Retention
     @Inherited
     @Documented
     @Repeatable (java1.8 新增)

***** @Target
      @Target 表示这个注解能放在什么位置上，是只能放在类上？还是即可以放在方法上，又可以放在属性上。自定义注解@JDBCConfig 这个注解上的@Target是：@Target({METHOD,TYPE})，表示他可以用在方法和类型上（类和接口），但是不能放在属性等其他位置。 可以选择的位置列表如下：
      ElementType.TYPE：能修饰类、接口或枚举类型
      ElementType.FIELD：能修饰成员变量
      ElementType.METHOD：能修饰方法
      ElementType.PARAMETER：能修饰参数
      ElementType.CONSTRUCTOR：能修饰构造器
      ElementType.LOCAL_VARIABLE：能修饰局部变量
      ElementType.ANNOTATION_TYPE：能修饰注解
      ElementType.PACKAGE：能修饰包

***** @Retention
      @Retention 表示生命周期，自定义注解@JDBCConfig 上的值是 RetentionPolicy.RUNTIME, 表示可以在运行的时候依然可以使用。 @Retention可选的值有3个：
      RetentionPolicy.SOURCE： 注解只在源代码中存在，编译成class之后，就没了。@Override 就是这种注解。
      RetentionPolicy.CLASS： 注解在java文件编程成.class文件后，依然存在，但是运行起来后就没了。@Retention的默认值，即当没有显示指定@Retention的时候，就会是这种类型。
      RetentionPolicy.RUNTIME： 注解在运行起来之后依然存在，程序可以通过反射获取这些信息，自定义注解@JDBCConfig 就是这样。

***** @Inherited
      @Inherited 表示该注解具有继承性。如例，做一个DBUtil的子类，其getConnection2方法，可以获取到父类DBUtil上的注解信息。

***** @Documented
      @Documented 在用javadoc命令生成API文档后，DBUtil的文档里会出现该注解说明。
      注： 使用eclipse把项目中的.java文件导成API文档步骤：
           1. 选中项目
           2. 点开菜单File
           3. 点击Export
           4. 点开java->javadoc->点next
           5. 点finish

***** @Repeatable (java1.8 新增)
      当没有@Repeatable修饰的时候，注解在同一个位置，只能出现一次，如例所示：
      @JDBCConfig(ip = "127.0.0.1", database = "test", encoding = "UTF-8", loginName = "root", password = "admin")
      @JDBCConfig(ip = "127.0.0.1", database = "test", encoding = "UTF-8", loginName = "root", password = "admin")
      重复做两次就会报错了。使用@Repeatable之后，再配合一些其他动作，就可以在同一个地方使用多次了。

****  仿Hibernate注解
*****  hibernate两种配置方式
       hibernate有两种配置方式，分别是*.hbm.xml 配置方式 和注解方式。 虽然方式不一样，但是都是用于解决如下问题：
          1. 当前类是否实体类
          2. 对应的表名称
          3. 主键对应哪个属性， 自增长策略是什么，对应字段名称是什么
          4. 非主键属性对应字段名称是什么

**** 注解分类
     1. 根据注解的作用域@Retention，注解分为
        RetentionPolicy.SOURCE： Java源文件上的注解
        RetentionPolicy.CLASS： Class类文件上的注解
        RetentionPolicy.RUNTIME： 运行时的注解
     2. 按照注解的来源，也是分为3类
        内置注解 如@Override ，@Deprecated 等等
        第三方注解，如Hibernate, Struts等等
        自定义注解，如fahibernate的自定义注解



** JAVA 应用
*** LOG4J
**** 入门
***** System.out.println
       通常，我们写代码的过程中，免不了要输出各种调试信息。在没有使用任何日志工具之前，都会使用 System.out.println 来做到。 这么做直观有效，但是有一系列的缺点：
           1. 不知道这句话是在哪个类，哪个线程里出来的
           2. 不知道什么时候前后两句输出间隔了多少时间
           3. 无法关闭调试信息，一旦System.out.println多了之后，到处都是输出，增加定位自己需要信息的难度

***** 使用Log4j
      为了应对这种情况，我们使用Log4j来进行日志输出。 采用如下代码，执行雷同的输出。 可以看到输出结果有几个改观：
          1. 知道是log4j.TestLog4j这个类里的日志
          2. 是在[main]线程里的日志
          3. 日志级别可观察，一共有6个级别 TRACE DEBUG INFO WARN ERROR FATAL
          4. 日志输出级别范围可控制， 如代码所示，只输出高于DEBUG级别的，那么TRACE级别的日志自动不输出
          5. 每句日志消耗的毫秒数(最前面的数字)，可观察，这样就可以进行性能计算


** JAVA 工具

*** Redis

**** 什么是Redis
     Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。
     换句话说，Redis就像是一个HashMap，不过不是在JVM中运行，而是以一个独立进程的形式运行。

**** Redis官网
     redis官网：http://redis.io
     windows版本的下载地址是： http://redis.io/download
     点击进去之后会跳转到： https://github.com/mythz/redis-windows

     从github上下载后，需要自己编译生成exe文件，但是为了编程生成exe文件，又需要用到Visual Studio一套，很是麻烦。

**** 运行
     启动服务端
       在解压后的目录下运行
       redis-server.exe

     启动客户端
       redis-cli.exe

     简单运用
       向服务器设置键值，并读取键值。
       set keys values
       get keys


**** 常见命令
     Redis目前有5种数据类型，分别是：
     String（字符串）
     List（列表）
     Hash（字典）
     Set（集合）
     Sorted Set（有序集合）
     不同的数据类型，有不同的命令方式

***** String 字符串
      set google http://www.google
      append google .com
      get google
      set visitors 0
      incr visitors
      incr visitors
      get visitors
      incrby visitors 100
      get visitors
      type google
      type visitors
      ttl google
      rename google google-site
      get google
      get google-site

      127.0.0.1:6379> set keys values
OK
127.0.0.1:6379> get keys
"values"
127.0.0.1:6379> get key
(nil)
127.0.0.1:6379> set google http://www.google
OK
127.0.0.1:6379> append google .com
(integer) 21
127.0.0.1:6379> get google
"http://www.google.com"
127.0.0.1:6379> set visitors 0
OK
127.0.0.1:6379> incr visitors
(integer) 1
127.0.0.1:6379> incr visitors
(integer) 2
127.0.0.1:6379> get visitors
"2"
127.0.0.1:6379> incrby visitors 100
(integer) 102
127.0.0.1:6379> get visitors
"102"
127.0.0.1:6379> type google
string
127.0.0.1:6379> type visitors
string
127.0.0.1:6379> ttl google
(integer) -1
127.0.0.1:6379> rename google google-site
OK
127.0.0.1:6379> get google
(nil)
127.0.0.1:6379> get google-site
"http://www.google.com"


***** List 列表
      lpush list1 redis
      lpush list1 hello
      rpush list1 world
      llen list1
      lrange list1 0 3
      lpop list1
      rpop list1
      lrange list1 0 3

127.0.0.1:6379> lpush list1 redis
(integer) 1
127.0.0.1:6379> lpush list1 hello
(integer) 2
127.0.0.1:6379> rpush list1 world
(integer) 3
127.0.0.1:6379> llen list1
(integer) 3
127.0.0.1:6379> lrange list1 0 3
1) "hello"
2) "redis"
3) "world"
127.0.0.1:6379> lpop list1
"hello"
127.0.0.1:6379> llen list1
(integer) 2
127.0.0.1:6379> lrange list1 0 3
1) "redis"
2) "world"
127.0.0.1:6379> rpop list1
"world"
127.0.0.1:6379> lrange list1 0 3
1) "redis"

***** Hash 字典，哈希表
      hset person name jack
      hset person age 20
      hset person sex famale
      hgetall person
      hkeys person
      hvals person

127.0.0.1:6379> hset person name jack
(integer) 1
127.0.0.1:6379> hset person age 20
(integer) 1
127.0.0.1:6379> hset person sex famale
(integer) 1
127.0.0.1:6379> hgetall person
1) "name"
2) "jack"
3) "age"
4) "20"
5) "sex"
6) "famale"
127.0.0.1:6379> hkeys person
1) "name"
2) "age"
3) "sex"
127.0.0.1:6379> hvals person
1) "jack"
2) "20"
3) "famale"

***** Set 集合
      SADD myset "Hello"
      SADD myset "World"
      SMEMBERS myset
      SADD myset "one"
      SISMEMBER myset "one"

127.0.0.1:6379> SADD myset "Hello"
(integer) 1
127.0.0.1:6379> SADD myset "World"
(integer) 1
127.0.0.1:6379> SMEMBERS myset
1) "World"
2) "Hello"
127.0.0.1:6379> SADD myset "one"
(integer) 1
127.0.0.1:6379> SISMEMBER myset "one"
(integer) 1
127.0.0.1:6379> SMEMBERS myset
1) "one"
2) "World"
3) "Hello"

***** Sorted Set 有序集合
      zadd dbs 100 redis
      zadd dbs 98 memcached
      zadd dbs 99 mongodb
      zadd dbs 99 leveldb
      zcard dbs
      zcount dbs 10 99
      zrank dbs leveldb
      zrank dbs other
      zrangebyscore dbs 98 100

127.0.0.1:6379> zadd dbs 100 redis
(integer) 1
127.0.0.1:6379> zadd dbs 98 memcached
(integer) 1
127.0.0.1:6379> zadd dbs 99 mongodb
(integer) 1
127.0.0.1:6379> zadd dbs 99 leveldb
(integer) 1
127.0.0.1:6379> zcard dbs
(integer) 4
127.0.0.1:6379> zcount dbs 10 99
(integer) 3
127.0.0.1:6379> zrank dbs leveldb
(integer) 1
127.0.0.1:6379> zrank dbs other
(nil)
127.0.0.1:6379> zrangebyscore dbs 98 100
1) "memcached"
2) "leveldb"
3) "mongodb"
4) "redis"

***** redis 命令查询地址
      http://www.redis.cn/commands.html

**** Jedis
***** 什么是Jedis
      在常见命令中，使用各种Redis自带客户端的命令行方式访问Redis服务。 而在实际工作中却需要用到Java代码才能访问，使用第三方jar包 ：Jedis就能方便地访问Redis的各种服务了。


*** NGINX

**** 入门
***** 启动和关闭
      1. 程序目录下，双击 nginx.exe 文件打开，通过任务管理器结束进程（两个）关。
      2. 程序目录下，执行“start nginx”，关闭执行“nginx -s stop”。
      执行后，通过访问：
         http://127.0.0.1
     确定服务是否启动

***** 配置文件
      nginx 的配置文件是 conf 目录下的 nginx.conf 文件。
      listen 80; # 端口号
      root html; # 页面存放目录
      index index.html index.htm # 欢迎页面


**** 反向代理

***** 代理
      先说正向代理，比如要访问youtube,但是不能直接访问，只能先找个翻墙软件，通过翻墙软件才能访问youtube. 翻墙软件就叫做正向代理。
      所谓的反向代理，指的是用户要访问youtube,但是youtube悄悄地把这个请求交给bilibili来做，那么bilibili就是反向代理了。
      在当前指的就是访问nginx,但是nginx把请求交给tomcat来做。

***** 配置
      修改配置文件 nginx.conf：

         location / {
                 proxy_pass http://127.0.0.1:8111;
         }

      重启 nginx
      nginx -s reload

      访问：
      http://127.0.0.0/

***** 配置的意义
      既然直接通过127.0.0.1:8111/login.jsp 可以访问，那么干嘛要通过127.0.0.1/login.jsp 去反向代理到tomcat呢？ 为什么不直接使用tomcat呢？

      因为nginx在处理静态文件的吞吐量上面比tomcat好很多，通常他们俩配合，不会把所有的请求都如本例所示的交给tomcat, 而是把静态请求交给nginx，动态请求，如jsp, servlet,ssm， struts等请求交给tomcat. 从而达到动静分离的效果。 接下来就会讲解如何进行动静分离。


**** 动静分离
***** 动静分离概念
      所谓的动静分离就是指图片，css, js之类的都交给nginx来处理，nginx处理不了的，比如jsp 就交给tomcat来处理。
      好处是nginx处理静态内容的吞吐量很高，比tomcat高多了，这样无形中提升了性能。

***** 配置
      在原有 location 后添加一个（注意正反斜杠和空格）
        location ~\.(css|js|png)$ {
            root C:/Users/Admin/Desktop/tomcat_8111/webapps/ROOT;
        }
      表示所有的css js png访问都由nginx来做，访问的地址是：C:/Users/Admin/Desktop/tomcat_8111/webapps/ROOT

***** 效果
      到tomcat的输出日志里观察，就会发现，只访问了jsp, 所有的css,js,png都不会经过 tomcat，而是由nginx自己负责处理了。


**** 负载均衡
***** 负载均衡概念
      当访问量很大的时候，一个 Tomcat 吃不消了，这时候就准备多个 Tomcat，由Nginx按照权重来对请求进行分配，从而缓解单独一个Tomcat受到的压力。

***** 配置
      在 server 前新增一个 upstream：
        upstream tomcat_8111_8222{
          server 127.0.0.1:8111 weight=1;
          server 127.0.0.1:8222 weight=2;
        }

      修改 location，反向代理到新增的配置：
        location / {
            proxy_pass http://tomcat_8111_8222;
        }

      重启 nginx 查看效果

***** 效果
      查看后台日志可以看到，多次访问项目地址后，被分配到了不同的 tomcat。


**** Session 共享

***** 负载均衡 session 问题
      通过负载均，我们可以把请求分发到不同的 Tomcat 来缓解服务器的压力，但是这里存在一个问题： 当同一个用户第一次访问tomcat_8111 并且登录成功， 而第二次访问却被分配到了tomcat_8222， 这里并没有记录他的登陆状态，那么就会呈现未登录状态了，严重伤害了用户体验。

***** 解决办法一：ip_hash
      通过ip地址标记用户，如果多次请求都是从同一个ip来的，那么就都分配到同一个tomcat.
这样就不会出现负载均衡 session问题了. 处理手段也很简单，在upstream最后加上ip_hash;就行了。
      upstream tomcat_8111_8222{
        server 127.0.0.1:8111 weight=1;
        server 127.0.0.1:8222 weight=2;
        ip_hash;
      }

      不过这种方案并不完美，当如下几种情况发生时就有问题：
          1. 大量请求来之某个局域网，那么相当于就没有负载均衡了
          2. 如果tomcat_8111 挂了，那么此时nginx只要把请求交给tomcat_8222,但是这里却没有记录session,用户体验依然受影响。

***** 解决办法二：redis + tomcat-session-manager
      用Redis来存取session.
      说简单点 redis 就是个独立的Hashmap，用来存放键值对的。
      这样当tomcat1需要保存session值的时候，就可以把它放在Redis上，需要取的时候，也从Redis上取。
      那么考虑这个情景：
          1. 用户提交账号密码的行为被分配在了tomcat8111上，登陆信息被存放在redis里。
          2. 当用户第二次访问的时候，被分配到了tomcat8222上
          3. 那么此时tomcat8222就会从redis去获取相关信息，一看有对应信息，那么就会呈现登陆状态。

***** 修改 context.xml 文件
      然后修改tomcat/conf/context.xml ，增加如下内容：
          <Valve className="com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve" />
          <Manager className="com.orangefunction.tomcat.redissessions.RedisSessionManager"
              host="127.0.0.1"
              port="6379"
              database="0"
              maxInactiveInterval="60" />

***** 效果
      访问：http://127.0.0.1:8111/login.jsp
      登录后，在新标签页访问另一个 tomcat 的访问地址：http://127.0.0.1:8222/login.jsp
      会看到一样的登录页面。


*** Linux 部署

**** 阿里云

***** 购买
      1. 阿里云官网地址：http://aliyun.com/
      2. 注册登录后进入“控制台”
      3. ECS就是云服务器，进入控制台后，点击左边的云服务器ECS->实例->创建实例 进入购买新实例界面
         需要自行选择“计费方式”、“地域”、“网络”、“实例规格”、“公网带宽”、“镜像”、“存储”、“购买量”、“安全设置”、“立即购买”。
         “计费方式”默认包年包月，之后可以选择周支付。
         “地域”默认选择华北1。
         “网络”默认设置，需要设置的“安全组”，就是指服务器开放什么端口让别人访问，默认只开放22和3389端口。
         “实例规格”选择最便宜的 ecs.t5-lc2m1.nano（单核512MB）
         “公网带宽”1M
         “镜像”公共镜像 CentOS 7.4
         “存储”40G
         “购买量”默认一年，最小可选单位1周
         “安全设置”设置账户、密码
         “立即购买”通过阿里云或支付宝的实名认证就可以支付了。


**** SecurityCRT
     Linux的文件系统和Windows不一样，windows有c盘，d盘，e盘，Linux 看上去就只有一个盘，/usr就是相当于硬盘上的usr目录。


**** FTP

***** 介绍
      File Transfer Protocol ： 文件传输协议。
      Linux上的ftp服务器有各种型号，我们会使用vsftpd，全称是：very secure FTP daemon 非常安全的ftp后台程序，ftp服务端。

***** 安装
      安装：
      $ yum install vsftpd -y

      查看服务状态
      $ systemctl status vsftpd.service
      如果 CentOS 使用的是7之前的，需要使用命令：
      $ service vsftpd status

      启动服务
      $ systemctl start vsftpd.service
      停止服务
      $ systemctl stop vsftpd.service

      检查端口
      $ netstat -anp | grep 21
      ftp 服务使用的端口号是 21，使用以上命令可以看到端口监听情况。

***** 配置服务用户
      创建目录
      $ mkdir -p /home/vsftpd

      创建用户并指定加目录（ftp 内置，不需要创建。nologin 禁止用户登录系统，但是可以登录 ftp 等）
      $ useradd -d /home/vsftpd -g ftp /sbin/nologin vsftpduser

      配置文件夹所有者及用户权限
      $ chown -R vsftpduser /home/vsftpd
      $ chmod -R 775 /home/vsftpduser

      设置用户密码
      $ passwd vsftpd

***** 配置权限
      vsftpd 服务器允许匿名登录，需要将该功能关闭。
      $ vi /etc/vsftpd/vsftpd.conf
      将
      anonymous_enable=YES
      更改为
      anonymous_enable=NO

      限定用户可访问目录，chroot_file 为限制用户的列表文件
      $ vi /etc/vsftpd/vsftpd.conf
      将
      #chroot_list_enable=YES
      #(default follows)
      #chroot_list_file=/etc/vsftpd/chroot_list
      修改为
      chroot_list_enable=YES
      #(default follows)
      chroot_list_file=/etc/vsftpd/chroot_list

      在 chroot_list 文件添加用户
      $ vi /etc/vsftpd/chroot_list
      添加 vsftpduser 后保存退出。

      vsftpd服务器会在某个用户被限制访问后，剥夺该用户的写权限。导致ftp客户端连接上服务器之后无法上传文件。
      在 vsftpd.conf 中为用户添加写权限
      $ vi /etc/vsftpd.conf
      添加如下内容：
      allow_writeable_chroot=YES

***** 配置端口
      vsftpd有两种端口，一个是21端口，用来监听客户端连接请求的。这个一般说来是固定的，就一直使用21端口。
      另一种是，一旦获取到请求之后，再专门用户服务端和客户端传输数据的端口。
      $ vi /etc/vsftpd/vsftpd.conf
      添加如下内容（使用被动模式，用于传输数据的端口分配从30000-31000之间）：
      pasv_enable=YES
      pasv_min_port=30000
      pasv_max_port=31000

      配置完成之后需要重新启动服务：
      $ systemctl restart vsftpd.service
      $ systemctl status vsftpd.service
      CentOS 7 之前的系统使用：
      $ service vsftpd restart
      $ service vsftpd status

***** CentOS 开放其他需要的端口
      在购买ECS服务器-网络步骤中，开通了22和3389端口。（22就是SecureCRT链接Linux服务器用的端口号。3389 是阿里云控制台链接用的端口，这里没有用到。）
      只有这两个端口号是不够用的，为了能够链接vsftpd服务器还需要开放21端口和 30000-31000端口。
      登陆阿里云后，按照如下顺序选择：云服务器ECS->安全组->配置规则，借助阿里云的安全组操作来实现端口的开放效果。

**** 快速安装 openJDK
     $ yum install install java-1.8.0-openjdk.x86_64 -y

**** 快速安装 MySQL
     在 yum 安装之前，需要获取社区版 MySQL
     $ cd /tmp
     $ wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm
     $ rpm -ivh mysql-community-release-el7-5.noarch.rpm
     $ yum install mysql mysql-server mysql-devel -y

     启动服务
     $ systemctl start mysql.service
     验证启动情况
     $ systemctl status mysql.service
     $ netstat -anp | grep 3306

     设置登录密码并登录验证
     $ mysqladmin -u root password admin
     $ mysql -uroot -padmin

**** tomcat
     安装（yum 没有 tomcat 的源）
     $ cd /tmp
     $ wget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-7/v7.0.82/bin/apache-tomcat-7.0.82.tar.gz
     $ tar -zxf apache-tomcat-7.0.82.tar.gz
     $ mv apache-tomcat-7.0.82 /usr/local/tomcat

     启动服务
     $ sh /usr/local/tomcat/apache-tomcat-7.0.82/bin/startup.sh
     查看端口占用情况
     $ netstat -anp | grep 8080
     查看输出日志
     $ tail -300f /usr/local/tomcat/apache-tomcat-7.0.82/logs/catalina.out

     有时候 tomcat 启动需要好几分钟，使用脚本关闭 tomcat，执行如下命令
     $ yum install rng-tools -y
     $ systemctl start rngd
     之后启动 tomcat 服务即可。

**** 部署应用

***** 配置 MySQL
      Windows 中对英文大小写不敏感，在 Linux 中是严格区分大小写的，对于 MySQL 可通过修改配置文件来使其对大小写不敏感。
      $ vi /etc/my.cnf
      在[mysqld]后添加添加：
      lower_case_table_names=1
      然后重启服务
      $ systemctl restart mysqld.service

***** 配置 tomcat
      添加项目启动路径，在<Host></Host>标签内添加
      $ vi /usr/local/tomcat/apache-tomcat-7.0.82/conf/server.xml
      <Context path="/tmall" docBase="/home/vsftpduser/tmall/web" debug="0" reloadable="false" />
      重新启动 tomcat，查看日志输出信息。


** 前端基础

*** HTML

**** 表单元素

***** 文本框
      <input type="text"> 即表示文本框，并且只能够输入一行。如果要输入多行，使用文本域<textarea>。
      注： <input> 标签很特别，一般是不需要写成<input />或者<input></input> 这样的。并且<input> 这样的写法也是满足标准的。

      placeholder是一个html5的属性，对于大多数的已经支持html5的浏览器来说，是可以看到效果的，但是对于老的不支持html5的浏览器，比如ie8，就看不到效果。

***** 单选框
      value属性有什么用？
      用于提交数据到服务端。

***** 图像提交
      <input type="image" src="http://how2j.cn/example.gif">
      image类型默认是提交。

*** CSS

**** 基础

***** 鼠标样式
      效果                      样式
      鼠标移动上来看效果        cursor:default
      鼠标移动上来看效果        cursor:auto
      鼠标移动上来看效果        cursor:crosshair
      鼠标移动上来看效果        cursor:pointer
      鼠标移动上来看效果        cursor:e-resize
      鼠标移动上来看效果        cursor:ne-resize
      鼠标移动上来看效果        cursor:nw-resize
      鼠标移动上来看效果        cursor:n-resize
      鼠标移动上来看效果        cursor:se-resize
      鼠标移动上来看效果        cursor:sw-resize
      鼠标移动上来看效果        cursor:w-resize
      鼠标移动上来看效果        cursor:text
      鼠标移动上来看效果        cursor:wait
      鼠标移动上来看效果        cursor:help

***** 超链状态
      伪类，所谓的伪类即被选中的元素处于某种状态的时候。

***** 优先级
      如果样式上增加了!important，则优先级最高，甚至高于style属性

**** 布局

*** JavaScript

**** 语言基础

***** Hello JavaScript

****** 通过javascript向文档中输出文本
       document是javascript的内置对象，代表浏览器的文档部分
       document.write("Hello Javascript"); 向文档写入字符串

***** 类型转换

****** 伪对象
       伪对象概念：javascript是一门很有意思的语言，即便是基本类型，也是伪对象，所以他们都有属性和方法。
       变量a的类型是字符串，通过调用其为伪对象的属性length获取其长度
       <script>
       var a="hello javascript";
       document.write("变量a的类型是:"+(typeof a));
       document.write("<br>");
       document.write("变量a的长度是:"+a.length);
       </script>

****** Number()和parseInt()的区别
       Number()和parseInt()一样，都可以用来进行数字的转换
       区别在于，当转换的内容包含非数字的时候，Number() 会返回NaN(Not a Number)，parseInt() 要看情况，如果以数字开头，就会返回开头的合法数字部分，如果以非数字开头，则返回NaN。

       <script>
       document.write("通过Number() 函数转换字符串'123' 后得到的数字："+Number("123"));   //正常的
       document.write("<br>");
       document.write("通过Number() 函数转换字符串'123abc' 后得到的数字："+Number("123abc"));   //包含非数字
       document.write("<br>");
       document.write("通过Number() 函数转换字符串'abc123' 后得到的数字："+Number("abc123"));   //包含非数字
       document.write("<br>");

       document.write("通过parseInt() 函数转换字符串'123' 后得到的数字："+parseInt("123"));   //正常的
       document.write("<br>");
       document.write("通过parseInt() 函数转换字符串'123abc' 后得到的数字："+parseInt("123abc"));   //包含非数字,返回开头的合法数字部分
       document.write("<br>");
       document.write("通过parseInt() 函数转换字符串'abc123' 后得到的数字："+parseInt("abc123"));   //包含非数字,以非数字开头，返回NaN
       document.write("<br>");
       </script>

****** String()和toString()的区别
       String()和toString()一样都会返回字符串，区别在于对null的处理
       String()会返回字符串"null"，toString() 就会报错，无法执行

       <script>
       var a = null;
       document.write('String(null) 把空对象转换为字符串：'+String(a));
       document.write("<br>");
       document.write('null.toString() 就会报错，所以后面的代码不能执行');
       document.write(a.toString());
       document.write("因为第5行报错，所以这一段文字不会显示");
       </script>

***** 逻辑运算符

****** 绝对等，绝对不等于
       与==进行值是否相等的判断不同 ，绝对等 ===还会进行 类型的判断
       比如 数字1和 字符串'1'比较，值是相等的，但是类型不同
       所以==会返回true,但是===会返回false
       绝对不等于!=== 与上是一个道理

       <script>
       function p(s){
       document.write(s);
       document.write("<br>");
       }

       p("1=='1': "+(1=='1'));
       p("1==='1': "+(1==='1'));
       </script>

**** 对象

***** 数组

****** 方法 join 通过指定分隔符，返回一个数组的字符串表达

****** 在最后的位置插入数据和获取数据(获取后删除)
       方法 push pop,分别在最后的位置插入数据和获取数据(获取后删除)，就像先入后出的栈一样

****** 在最开始的位置插入数据和获取数据(获取后删除)
       方法 unshift shift ,分别在最开始的位置插入数据和获取数据(获取后删除)

****** 对数组的内容进行反转
       方法 reverse，对数组的内容进行反转

****** 获取子数组
       方法 slice 获取子数组

****** 删除和插入元素
       方法 splice (不是 slice) 用于删除数组中的元素
       奇葩的是 ，它还能用于向数组中插入元素

***** Math

******  绝对值
        方法 abs 取绝对值

****** 求幂
       方法 pow 求一个数的n次方

****** 四舍五入
       方法 round,小数四舍五入取整

****** 随机数
       方法 random 取0-1之间的随机数

**** BOM
     BOM即 浏览器对象模型(Brower Object Model)
     浏览器对象包括: Window(窗口)、Navigator(浏览器)、Screen (客户端屏幕)、History(访问历史)、Location(浏览器地址)。

***** Window

****** 获取文档显示区域的高度和宽度
       一旦页面加载，就会自动创建window对象，所以无需手动创建window对象。
       通过window对象可以获取文档显示区域的高度和宽度

       <script>
       document.write("文档内容");
       document.write("文档显示区域的宽度"+window.innerWidth);
       document.write("<br>");
       document.write("文档显示区域的高度"+window.innerHeight);
       </script>

******  获取外部窗体的宽度和高度
        所谓的外部窗体即浏览器，可能用的是360，火狐，IE, Chrome等等。

***** Navigator
      Navigator即浏览器对象，提供浏览器相关的信息

      <script type="text/javascript">
      document.write("<p>浏览器产品名称：");
      document.write(navigator.appName + "</p>");

      document.write("<p>浏览器版本号：");
      document.write(navigator.appVersion + "</p>");

      document.write("<p>浏览器内部代码：");
      document.write(navigator.appCodeName + "</p>");

      document.write("<p>操作系统：");
      document.write(navigator.platform + "</p>");

      document.write("<p>是否启用Cookies：");
      document.write(navigator.cookieEnabled + "</p>");

      document.write("<p>浏览器的用户代理报头：");
      document.write(navigator.userAgent + "</p>");
      </script>

***** Screen
      Screen对象表示用户的屏幕相关信息

      <script type="text/javascript">
      document.write("用户的屏幕分辨率: ")
      document.write(screen.width + "*" + screen.height)
      document.write("<br />")
      document.write("可用区域大小: ")
      document.write(screen.availWidth + "*" + screen.availHeight)
      document.write("<br />")
      </script>

***** History
      History用于记录访问历史

***** Location
      Location表示浏览器中的地址栏

      <script>
      function p(s){
      document.write(s);
      document.write("<br>");
      }

      p("协议 location.protocol:"+location.protocol);
      p("主机名 location.hostname:"+location.hostname);
      p("端口号 (默认是80，没有即表示80端口)location.port:"+location.port);

      p("主机加端口号 location.host:"+location.host);
      p("访问的路径  location.pathname:"+location.pathname);

      p("锚点 location.hash:"+location.hash);
      p("参数列表 location.search"+location.search);
      </script>

***** 计时器

****** 只执行一次
       函数setTimeout(functionname, 距离开始时间毫秒数 );通过setTimeout在制定的毫秒数时间后，执行一次 函数functionname
       本例在3秒钟后，打印当前时间。
       解释:document.getElementById 获取id=time的div元素 .innerHTML 修改该元素的内容

****** 不停地重复执行
       函数setInterval(函数名, 重复执行的时间间隔毫秒数 );
       通过setInterval重复执行同一个函数，重复的时间间隔由第二个参数指定

****** 终止重复执行
       通过clearInterval终止一个不断重复的任务

****** 不要在setInterval调用的函数中使用document.write();
       注：部分浏览器，比如firefox有这个问题，其他浏览器没这个问题。
       假设setInterval调用的函数是printTime, 在printTime中调用document.write(); 只能看到一次打印时间的效果。
       这是因为document.write，会创建一个新的文档，而新的文档里，只有打印出来的时间字符串，并没有setInterval这些javascript调用，所以只会看到执行一次的效果。

*** HTML DOM

**** 节点概念
     DOM 是Document Object Model( 文档对象模型 )的缩写。
     DOM是把html里面的各种数据当作对象进行操作的一种思路。比如一个超链，作为一个DOM对象，就可以使其隐藏，修改其href指向的地址。

     DOM把所有的html都转换为节点：整个文档 是一个节点，元素 是节点，元素属性 是节点，元素内容 是节点，注释 也是节点
     通过document.getElementById获取了id=d1的div标签对应的元素节点，然后通过attributes 获取了该节点对应的属性节点，接着通过childNodes获取了内容节点

**** 获取节点

***** 获取属性节点
      首先通过getElementById获取元素节点，然后通过元素节点的attributes获取其下所有的属性节点。
      因为属性节点是多个，所以是以数组的形式返回出来的，接着通过for循环遍历，查看每个节点的nodeName和nodeValue（一个节点的名称和值）。如果要获取一个指定属性的值，可以采用如下风格，as表示所有的属性，as["id"]取出名称是id的属性：as["id"].nodeValue

**** 节点的属性

***** 节点名称
      nodeName表示一个节点的名字

      document.nodeName 文档的节点名，是 固定的#document
      div1.nodeName 元素的节点名，是对应的标签名 div
      div1.attributes[0].nodeName 属性的节点名，是对应的属性名 id
      div1.childNodes[0].nodeName 内容的节点名，是固定的 #text

***** 节点值
      nodeValue表示一个节点的值

      document.nodeValue 文档的节点值，是 null
      div1.nodeValue 元素的节点值，是null
      div1.attributes[0].nodeValue 属性的节点值，是对应的属性值 d1
      div1.childNodes[0].nodeValue 内容的节点值，是内容 #text

***** 节点类型
      nodeType表示一个节点的值，不同的节点类型，对应的节点类型值是不一样的

      document.nodeType 文档的节点类型，是 9
      div1.nodeType 元素的节点类型，是 1
      div1.attributes[0].nodeType 属性的节点类型，是 2
      div1.childNodes[0].nodeType 内容的节点类型，是 3

**** 事件

***** 焦点事件
      焦点相关的事件，分别有获取焦点和失去焦点
      当组件获取焦点的时候，会触发onfocus事件
      当组件失去焦点的时候，会触发onblur事件

***** 鼠标事件
      鼠标事件，由鼠标按下，鼠标弹起，鼠标经过，鼠标进入，鼠标退出几个事件组成
      当在组件上鼠标按下的时候，会触发onmousedown事件
      当在组件上鼠标弹起的时候，会触发onmouseup事件

      当在组件上鼠标经过的时候，会触发onmousemove事件
      当在组件上鼠标进入的时候，会触发onmouseover事件
      当在组件上鼠标退出的时候，会触发onmouseout事件
      注: 当鼠标进入一个组件的时候，onmousemove和onmouseover都会被触发，区别在于无论鼠标在组件上如何移动，onmouseover只会触发一次，onmousemove每次移动都回触发

*****  键盘事件
       键盘事件，由键盘按下keydown，键盘按下keypress,键盘弹起几个事件组成
       当在组件上键盘按下的时候，会触发onkeydown事件
       当在组件上键盘按下的时候，也会触发onkeypress事件
       当在组件上键盘弹起的时候，会触发onkeyup事件
       注: onkeypress 是当按下并弹起的组合动作，这个说法是错误的

       都是用于表示键盘按下，onkeydown和onkeypress的区别在什么呢？
       onkeydown
       可以获取所有键，除了打印键Prts
       可以获取用户是否点击了修饰键 (ctrl,shift,alt)
       不能判断输入的是大写还是小写
       onkeypress
       只能获取字符键
       不能获取用户是否点击了修饰键 (ctrl,shift,alt)
       可以判断输入的是大写还是小写

       但是！ 在不同的浏览器上，以上规则是不成立的。说这些都没有卵用，你无法控制用户到底使用哪种浏览器。 所以，只要记得keydown和keypress都表示点下了键。。。即可

***** 点击事件
      点击事件，由单击，双击按两个事件组成
      当在组件上单击的时候，会触发onclick事件
      当在组件上双击的时候，会触发ondblclick事件
      注1：在组件上，按下空格或则回车键也可以造成单击的效果，但是却不能造成双击的效果
      注2: 自定义函数不要使用click()，这是保留函数名。

***** 变化事件
      当组件的值发生变化的时候，会触发onchange事件
      注：对于输入框而言，只有在失去焦点的时候，才会触发onchange，所以需要点击一下"按钮" 造成输入框失去焦点

***** 提交事件
      可以在form元素上，监听提交事件
      当form元素@提交的时候，会触发onsubmit事件

*****  加载事件
       当整个文档加载成功，或者一个图片加载成功，会触发加载事件
       当body元素或者img@加载的时候，会触发onload事件

*****  当前组件
       this表示触发事件的组件，可以在调用函数的时候，作为参数传进去

***** 阻止事件的发生
      比如在提交一个表单的时候，如果用户名为空，弹出提示，并阻止原本的提交
          1. 在调用函数的时候，增加一个return
          2. 在函数中，如果发现用户名为空，则返回false
          3. 当onSubmit得到的返回值是false的时候，表单的提交功能就被取消了

**** 节点关系

***** 父节点关系
      通过parentNode获取父节点。

***** 同胞节点关系
      分别通过 previousSibling和nextSibling属性获取前一个，以及后一个同胞节点。

***** 子节点关系
      子节点关系有:
          firstChild 第一个子节点
          lastChild 最后一个子节点
          childNodes 所有子节点
      注:firstChild 如果父节点的开始标签和第一个元素的开始标签之间有文本、空格、换行，那么firstChild第一个子节点将会是文本节点，不会是第一个元素节点

*****  childNodes和children的区别
       childNodes和children都可以获取一个元素节点的子节点。
       childNodes 会包含文本节点
       children 会排除文本节点

**** 创建节点

*****  创建元素节点
       通过createElement 创建一个新的元素节点

*****  创建文本节点
       首先创建一个元素节点p (p是p标签，不是随便命名的变量名)
       接着通过createTextNode创建一个内容节点text
       把text加入到p
       再把p加入到div

*****  创建属性节点
       首先创建一个元素节点a
       接着创建一个内容节点content
       把content加入到a
       然后通过createAttribute创建一个属性节点 href
       设置href的值为http:12306.co``m
       通过setAttributeNode把该属性设置到元素节点a上
       最后把a加入到div

**** 删除节点

*****  删除元素节点
       要删除某个元素节点有两步
           第一：先获取该元素的父节点
           第二：通过父节点，调用removeChild 删除该节点

*****  删除属性节点
       要删除某个属性节点有两步
       第一：先获取该元素节点
       第二：元素节点，调用removeAttribute删除指定属性节点

***** 删除文本节点
      1. 通过childNodes[0] 获取文本节点
      注:children()[0] 只能获取第一个子元素节点，不能获取文本节点
      2. 通过removeChild删除该文本节点

**** 替换节点

*****  替换节点
       与删除节点一样，替换节点也需要先获取父节点，然后通过父节点替换子节点。
           1. 获取父节点
           2. 创建子节点
           3. 获取被替换子节点
           4. 通过replaceChild进行替换
           注: replaceChild 第一个参数是保留的节点，第二个参数是被替换的节点

**** 插入节点

***** 追加节点
      通过appendChild追加节点。 追加节点一定是把新的节点插在最后面
          1. 创建新节点
          2. 获取父节点
          3. 通过appendChild追加

***** 在前方插入节点
      有时候，需要在指定位置插入节点，而不是只是追加在后面。
      这个时候就需要用到insertBefore
          1. 创建新节点
          2. 获取父节点
          3. 获取需要加入的子节点
          4. 通过insertBefore插入
          注: insertBefore的第一个参数是新元素，第二个参数是插入位置

*** jQuery

**** Hello jQuery

***** 理解 $(function(){})
      $(function(){}); 表示文档加载。看上去略复杂，其实是由下面两种构成：
      $(); 和 function(){}
      合并在一起就是：$(function(){});
      这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。换句话说，写在这里面的JQuery代码都是文档加载好之后的。就不会有获取一个还没有加载好的图片这种问题了。
      一样功能，还有另一个写法：
      $(document).ready(function(){});
      它也是由两部分组成：
      $(document).ready();
      function(){}

**** 常见方法

*****  取值
       通过JQuery对象的val()方法获取值
       相当于 document.getElementById("input1").value;
       alert($("#input1").val());

*****  获取元素内容,如果有子元素，保留标签
       通过html() 获取元素内容,如果有子元素，保留标签
       alert($("#d1").html());

***** 获取元素内容,如果有子元素，不包含子元素标签
      通过text() 获取元素内容,如果有子元素，不包含标签
      alert($("#d1").text());

**** CSS

***** 增加class
      通过addClass() 增加一个样式中的class
      $("#d").addClass("pink");

*****  删除class
       通过removeClass() 删除一个样式中的class
       $("#d").removeClass("pink");

***** 切换class
      通过toggleClass() 切换一个样式中的class
      这里的切换，指得是：如果存在就删除，如果不存在，就添加。
      $("#d").toggleClass("pink");

***** css函数
      通过css函数 直接设置样式
      css(property,value)
      $("#d1").css("background-color","pink");
      $("#d2").css({"background-color":"pink","color":"green"});

**** 选择器

***** 属性
      $(selector[attribute]) 满足选择器条件的有某属性的元素
      $(selector[attribute=value]) 满足选择器条件的属性等于value的元素
      $(selector[attribute!=value]) 满足选择器条件的属性不等于value的元素
      $(selector[attribute^=value]) 满足选择器条件的属性以value开头的元素
      $(selector[attribute$=value]) 满足选择器条件的属性以value结尾的元素
      $(selector[attribute*=value]) 满足选择器条件的属性包含value的元素

      注： 一般不要使用[class=className] 而应该使用.className。
      因为使用$("[class='className']") .toggleClass("anotherClassName")，会导致class变成className anotherClassName,再次 使用 [class=className] 就无法选中了，而.className没有这个问题。

*****  表单对象
       表单对象选择器 指的是选中form下会出现的输入元素
       :input 会选择所有的输入元素，不仅仅是input标签开始的那些，还包括textarea,select和button
       :button 会选择type=button的input元素和button元素
       :radio 会选择单选框
       :checkbox会选择复选框
       :text会选择文本框，但是不会选择文本域
       :submit会选择提交按钮
       :image会选择图片型提交按钮
       :reset会选择重置按钮

***** 表单对象属性
      :enabled会选择可用的输入元素 注：输入元素的默认状态都是可用
      :disabled会选择不可用的输入元素
      :checked会选择被选中的单选框和复选框 注： checked在部分浏览器上(火狐,chrome)也可以选中selected的option
      :selected会选择被选中的option元素

**** 筛选器

***** 第一个 最后一个 第几个
      首先通过 $("div") 选择了多个div元素，接下来做进一步的筛选
      first() 第1个元素
      last() 最后1个元素
      eq(num) 第num个元素
      注: num基0

***** 父 祖先
      parent() 选取最近的一个父元素
      parents() 选取所有的祖先元素

***** 儿子 后代
      children(): 筛选出儿子元素 (紧挨着的子元素)
      find(selector): 筛选出后代元素
      注: find() 必须使用参数 selector

***** 同级
      siblings(): 同级(同胞)元素

**** 属性

***** 获取
      通过attr()获取一个元素的属性

***** 修改
      通过attr(attr,value)修改属性

***** 删除
      通过removeAttr(attr)删除属性

***** prop与attr的区别
      与prop一样attr也可以用来获取与设置元素的属性。
      区别在于，对于自定义属性和选中属性的处理。
      选中属性指的是 checked,selected 这2种属性
          1. 对于自定义属性 attr能够获取，prop不能获取
          2. 对于选中属性 attr 只能获取初始值，无论是否变化
          prop 能够访问变化后的值，并且以true|false的布尔型返回。所以在访问表单对象属性的时候，应该采用prop而非attr。

**** 效果

*****  显示 隐藏 切换
       显示 隐藏 切换 分别通过show(), hide(),toggle()实现，也可以加上毫秒数，表示延时操作,比如show(2000) 。

***** 向上滑动 向下滑动 滑动切换
      向上滑动 向下滑动 滑动切换 分别通过slideUp(), slideDown(),slideToggle()实现，也可以加上毫秒数，表示延时操作，比如slideUp(2000)。

*****  淡入 淡出 淡入淡出切换 指定淡入程度
       淡入 淡出 淡入淡出切换 指定淡入程度 分别通过fadeIn(), fadeOut(),fadeToggle() fadeTo()实现，也可以加上毫秒数，表示延时操作，比如fadeIn(2000)，fadeTo跟的参数是0-1之间的小数。 0表示不淡入，1表示全部淡入。

***** 自定义动画效果
      通过animate 可以实现更为丰富的动画效果，animate()第一个参数为css样式，animate()第二个参数为延时毫秒。
      注： 默认情况下，html中的元素都是固定，并且无法改变的位置的。 为了使用animate()自定义动画效果，需要通过css把元素的position设置为relative、absolute或者fixed。

*****  回调函数
       效果一般需要一定的时间，并且这个时间可长可短，所以就无法精确的确定该效果合适结束。好在，效果方法都提供对回调函数callback()的支持。只需要在调用效果方法的最后一个参数传入一个function，当效果结束的时候，就会自动调用该function了。

**** 事件

***** 加载
      页面加载有两种方式表示
      1. $(document).ready();
      2. $(); 这种比较常用
      图片加载用load()函数

***** 点击
      click() 表示单击，dblclick() 表示双击
      注: 空白键和回车键也可以造成click事件，但是只有双击鼠标才能造成dblclick事件

*****  键盘
       keydown 表示按下键盘，keypress 表示按下键盘，keyup 表示键盘弹起
       这三者的区别分别表现在发生的 先后顺序，获取到的键盘按钮值，已经对输入框的文本取值这三方面。
       先后顺序： 按照 keydown keypress keyup 顺序发生
       键盘按钮值：通过event对象的which属性获取键盘的值，keydown和keyup 能获取所有按键，不能识别大小写，keypress 不能获取功能键，如F1 SHIFT等，能够识别大小写
       文本取值：keydown和keypress：不能获取最后一个字符，keyup： 获取所有字符

***** 鼠标
      mousedown 表示鼠标按下
      mouseup表示鼠标弹起

      mousemove表示鼠标进入
      mouseenter表示鼠标进入
      mouseover表示鼠标进入

      mouseleave表示鼠标离开
      mouseout表示鼠标离开

      进入事件有3个 mousemove mouseenter mouseover：
          mousemove ：当鼠标进入元素，每移动一下都会被调用
          mouseenter ：当鼠标进入元素，调用一下，在其中移动，不调用
          mouseover：当鼠标进入元素，调用一下，在其中移动，不调用

      mouseenter 和 mouseover的区别
          mouseenter: 当鼠标经过其子元素不会被调用
          mouseover：当鼠标经过其子元素会被调用

      mouseleave 和 mouseout的区别
          mouseleave: 当鼠标经过其子元素不会被调用
          mouseout：当鼠标经过其子元素会被调用

***** 焦点
      focus() 获取焦点，blur() 失去焦点

***** 改变
      change() 内容改变
      注： 对于文本框，只有当该文本失去焦点的时候，才会触发change事件。

*****  提交
       submit() 提交form表单

***** 绑定事件
      以上所有的事件处理，都可以通过on() 绑定事件来处理
      $("selector").on("event",function);

*****  触发事件
       触发事件，在本例中，文档加载好之后，就触发dblclick双击事件，而不是通过去手动双击。
       $("selector").trigger("event");

**** AJAX

***** 提交AJAX请求
      完整的 $.ajax 参数 比较复杂，这里采用了常见的调用方式。
      $.ajax({
        url: page,
        data:{"name":value},
        success: function(result){
          $("#checkResult").html(result);
        }
      });

      $.ajax采用参数集的方式 {param1,param2,param3} 不同的参数之间用,隔开
      第一个参数 url:page 表示访问的是page页面
      第二个参数 data:{name:value} 表示提交的参数
      第三个参数 success: function(){} 表示服务器成功返回后对应的响应函数

*****  使用get方式提交ajax
       $.get 是 $.ajax的简化版，专门用于发送GET请求
       $.get(
            page,
            {"name":value},
            function(result){
              $("#checkResult").html(result);
            }
       );

       $.get 使用3个参数，第一个参数: page 访问的页面，第二个参数: {name:value} 提交的数据，第三个参数: function(){} 响应函数。
       只有第一个参数是必须的，其他参数都是可选

***** 使用post方式提交ajax
      $.post 是 $.ajax的简化版，专门用于发送POST请求
      $.post(
        page,
        {"name":value},
        function(result){
          $("#checkResult").html(result);
        }
      );

      $.post 使用3个参数，第一个参数: page 访问的页面，第二个参数: {name:value} 提交的数据，第三个参数: function(){} 响应函数。
      只有第一个参数是必须的，其他参数都是可选

***** 最简单的调用ajax的方式
      load比起 $.get,$.post 就更简单了
      $("#id").load(page,[data]);
      id: 用于显示AJAX服务端文本的元素Id
      page: 服务端页面
      data: 提交的数据，可选。 在本例中，直接在page里加上了参数列表

***** 格式化form下的输入数据
      serialize()： 格式化form下的输入数据
      有的时候form下的输入内容比较多，一个一个的取比较麻烦，就可以使用serialize() 把输入数据格式化成字符串
      var data = $("#form").serialize(); // 格式化 form 表单的数据

**** 数组操作

*****  遍历
       $.each 遍历一个数组，第一个参数是数组，第二个参数是回调函数 i是下标，n是内容
         var a = new Array(1,2,3);
         $.each( a, function(i, n){
           document.write( "元素[" + i + "] : " + n + "<br>" );
         })
         document.close();

*****  去除重复
       $.unique() 去掉重复的元素
         var a = new Array(5,2,4,2,3,3,1,4,2,5);
         a.sort();
         $.unique(a);
       注意 ： 执行unique之前，要先调用sort对数组的内容进行排序。

*****  是否存在$.inArray
       $.inArray 返回元素在数组中的位置 ，如果不存在返回-1
         var a = new Array(1,2,3,4,5,6,7,8);
         document.write($.inArray(9,a));
         document.close();

**** 字符串操作

***** 去除首尾空白
      $.trim() 去除首尾空白

**** JSON

*****  将JSON格式的字符串，转换为JSON对象
       $.parseJSON 将JSON格式的字符串，转换为JSON对象
         $.parseJSON(s3);

**** 对象转换

*****  JQuery转DOM
       通过get(0)或者[0] 把JQuery对象转为DOM对象
         var div= $("#d"); // jQuery 对象
         var d = div[0]; // DOM 对象

***** DOM转JQuery
      通过$() 把DOM对象转为JQuery对象
        var div= document.getElementById("d"); // DOM 对象
        var d = $(div); // jQuery 对象

*** BootStrap

**** 如何使用

*****  <!DOCTYPE html>
       因为bootstrap用到了html5的特性，为了正常使用，需要在最开头加上
       <!DOCTYPE html>

***** 导入js 导入css
      接着导入js和css
        Bootstrap需要JQuery才能正常工作，所以需要导入jquery.min.js
        接着是 Bootstrap的css，里面定义了各种样式
        最后是 Bootstrap的js，用于产生交互效果，比如关闭警告框
      注：顺序不要搞错了，否则有一些效果会出不来。






** J2EE

*** Tomcat

**** 端口被占用

*****  查看80端口被哪些程序占用了
       使用命令
       netstat -ano|findstr "80"
       （必须使用双引号）查看 端口号包含"80"的占用情况。

*****  根据pid（进程id） 查询对应的应用程序
       使用命令
       tasklist|findstr "1828"
       (必须使用双引号)1828根据上一步找到的对应的pid。

*****  根据名称 结束该程序
       最后使用  taskkill /f /t /im java.exe  结束java.exe。
       结束成功会提示：
           成功： 已终止 。。。

**** 持久化异常
      Tomcat启动的时候会报一个Exception loading sessions from persistent storage异常
      该问题的原因是tomcat的session持久化机制引起的，tomcat这个功能本身的用意在于重启tomcat后保存之前的session，Tomcat会把session持久化在%TOMCAT%/work/Catalina/localhost/session.ser 这个文件里。 但是因为tomcat非正常关闭，所以这个文件没有正确地结束(无EOF标记)
      解决办法治标： 只需要删除 session.ser文件即可。
      解决办法治本：关闭tomcat的持久化功能，就能一劳永逸的解决这个问题。具体为修改conf下的server.xml文件。在项目的context间加入一句代码
      <Manager className="org.apache.catalina.session.PersistentManager" saveOnRestart="false"/>
      重启tomcat以后再也不会报这个错误了。
      <Context path="/" docBase="D:\\project\\j2ee\\web" debug="0" reloadable="false" >
      <Manager className="org.apache.catalina.session.PersistentManager" saveOnRestart="false"/>
      </Context>

*** Servlet

**** 基础

***** service()
      LoginServlet继承了HttpServlet,同时也继承了一个方法
      service(HttpServletRequest , HttpServletResponse )
      实际上，在执行doGet()或者doPost()之前，都会先执行service()，由service()方法进行判断，到底该调用doGet()还是doPost()。
      可以发现，service(), doGet(), doPost() 三种方式的参数列表都是一样的。所以，有时候也会直接重写service()方法，在其中提供相应的服务，就不用区分到底是get还是post了。

***** 中文乱码
      <meta charset="UTF-8">
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      效果一致，只是上边是 h5，下边对之前版本也有支持。

***** 跳转
      跳转的方式有两种，服务端跳转和客户端跳转。

***** 服务器端传参
      setAttribute和getAttribute可以用来在进行服务端跳转的时候，在不同的Servlet之间进行数据共享。

***** Eclipse 无法正常配置 tomcat
      定位到项目目录下 \.metadata\.plugins\org.eclipse.core.runtime\.settings
      删除：org.eclipse.wst.server.core.prefs 和 org.eclipse.jst.server.tomcat.core.prefs

*** JSP

**** 执行过程
     1. 把 hello.jsp转译为hello_jsp.java
     2. hello_jsp.java 位于 d:\tomcat\work\Catalina\localhost\_\org\apache\jsp
     3. hello_jsp.java是一个servlet
     4. 把hello_jsp.java 编译为hello_jsp.class
     5. 执行hello_jsp.class，生成html
     6. 通过http协议把html 响应返回给浏览器

**** 页面元素
     jsp由这些页面元素组成：
     1. 静态内容  就是html,css,javascript等内容
     2. 指令  以<%@开始 %> 结尾，比如<%@page import="java.util.*"%>
     3. 表达式 <%=%>  用于输出一段html
     4. Scriptlet  在<%%> 之间，可以写任何java 代码
     5. 声明  在<%!%> 之间可以声明字段或者方法。但是不建议这么做。
     6. 动作  <jsp:include page="Filename" > 在jsp页面中包含另一个页面。在包含的章节有详细的讲解
     7. 注释 <%-- -- %>  不同于 html的注释 <!-- --> 通过jsp的注释，浏览器也看不到相应的代码，相当于在servlet中注释掉了

****  指令include和动作include的区别
      通过之前的学习知道，JSP最后会被转译成Servlet

      如果是指令include <%@include file="footer.jsp" %> footer.jsp的内容会被插入到 hello.jsp 转译 成的hello_jsp.java中，最后只会生成一个hello_jsp.java文件

      如果是动作include <jsp:include page="footer.jsp" /> footer.jsp的内容不会被插入到 hello.jsp 转译 成的hello_jsp.java中，还会有一个footer_jsp.java独立存在。 hello_jsp.java 会在服务端访问footer_.jsp.java,然后把返回的结果，嵌入到响应中。

**** cookie
     Cookie是一种浏览器和服务器交互数据的方式。
     Cookie是由服务器端创建，但是不会保存在服务器。
     创建好之后，发送给浏览器。浏览器保存在用户本地。
     下一次访问网站的时候，就会把该Cookie发送给服务器。

**** session
     Session对应的中文翻译是会话。
     会话指的是从用户打开浏览器访问一个网站开始，无论在这个网站中访问了多少页面，点击了多少链接，直到该用户关闭浏览器为止，都属于同一个会话。

     盒子对应服务器上的Session。
     钥匙对应浏览器上的Cookie。

**** 作用域
     JSP有4个作用域，分别是：pageContext 当前页面、requestContext 一次请求、sessionContext 当前会话。

*****  pageContext
       pageContext表示当前页面作用域，通过pageContext.setAttribute(key,value)的数据，只能在当前页面访问，在其他页面就不能访问了。

***** requestContext
      requestContext 表示一次请求。随着本次请求结束，其中的数据也就被回收。

***** requestContext与服务端跳转
      requestContext与服务端跳转时，requestContext指的是一次请求。如果发生了服务端跳转，从setContext.jsp跳转到getContext.jsp，这其实，还是一次请求。 所以在getContext.jsp中，可以取到在requestContext中设置的值。这也是一种页面间传递数据的方式。

*****  requestContext与客户端跳转
       requestContext与客户端跳转时，客户端跳转，浏览器会发生一次新的访问，新的访问会产生一个新的request对象。所以页面间客户端跳转的情况下，是无法通过request传递数据的。

***** sessionContext
      sessionContext 指的是会话，从一个用户打开网站的那一刻起，无论访问了多少网页，链接都属于同一个会话，直到浏览器关闭。所以页面间传递数据，也是可以通过session传递的。但是，不同用户对应的session是不一样的，所以session无法在不同的用户之间共享数据。

***** applicationContext
      applicationContext 指的是全局，所有用户共享同一个数据。
      在JSP中使用application对象，application对象是ServletContext接口的实例。也可以通过 request.getServletContext()来获取。所以 application == request.getServletContext() 会返回true。application映射的就是web应用本身。

**** 隐式对象
     request 代表请求
     response 代表响应
     out 代表输出
     pageContext 代表当前页面作用域
     session 代表当会话作用域
     application 代表当全局作用域
     page 对象即表示当前对象，JSP 会被编译为一个Servlet类 ，运行的时候是一个Servlet实例。page即代表this。
     config可以获取一些在web.xml中初始化的参数。
     exception 对象只有当前页面的<%@page 指令设置为isErrorPage="true"的时候才可以使用。同时，在其他页面也需要设置 <%@page 指令 errorPage="" 来指定一个专门处理异常的页面。

**** EL 表达式
     为了保证EL表达式能够正常使用，需要在<%@page 标签里加上isELIgnored="false"
     用JSTL输出要写成：<c:out value="${name}" />，但是用EL只需要：${name}

*** Filter

**** 中文处理
     按照MVC的设计模式，视图会交由jsp负责，而在jsp最上面一般都会加上 <%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" import="java.util.*"%> 其作用之一，就等同于response.setContentType("text/html; charset=UTF-8");



** JAVA 框架

*** Hibernate

**** 基础
***** hello hibernate

****** 创建数据库和表
       create database test;
       use test;
       CREATE TABLE product_ (
       id int(11) NOT NULL AUTO_INCREMENT,
       name varchar(30) ,
       price float ,
       PRIMARY KEY (id)
       ) DEFAULT CHARSET=UTF8;

***** 对象状态
      new 了一个Product();，在数据库中还没有对应的记录，这个时候Product对象的状态是瞬时的。

      通过Session的save把该对象保存在了数据库中，该对象也和Session之间产生了联系，此时状态是持久的。

      最后把Session关闭了，这个对象在数据库中虽然有对应的数据，但是已经和Session失去了联系，相当于脱离了管理，状态就是脱管的。

***** 查询-hql
HQL（Hibernate Query Language）是hibernate专门用于查询数据的语句，有别于SQL，HQL跟接近于面向对象的思维方式。
****** 使用HQL,根据name进行模糊查询
       1. 首先根据hql创建一个Query对象
       2. 设置参数(和基1的PreparedStatement不一样，Query是基0的)
       3. 通过Query对象的list()方法即返回查询的结果了。
       注： 使用hql的时候，不需要在前面加 select *。
***** 查询-Criteria
      使用Criteria进行数据查询。
      与HQL和SQL的区别是Criteria 完全是 面向对象的方式在进行数据查询，将不再看到有sql语句的痕迹。
******  使用Criteria,根据name进行模糊查询
        使用Criteria 查询数据
        1. 通过session的createCriteria创建一个Criteria 对象
        2. Criteria.add 增加约束。 在本例中增加一个对name的模糊查询(like)
        3. 调用list()方法返回查询结果的集合

***** 查询-标准 sql
     通过标准SQL语句进行查询
     Hibernate依然保留了对标准SQL语句的支持，在一些场合，比如多表联合查询，并且有分组统计函数的情况下，标准SQL语句依然是效率较高的一种选择。

     使用Session的createSQLQuery方法执行标准SQL语句
     因为标准SQL语句有可能返回各种各样的结果，比如多表查询，分组统计结果等等。 不能保证其查询结果能够装进一个Product对象中，所以返回的集合里的每一个元素是一个对象数组。 然后再通过下标把这个对象数组中的数据取出来。

**** 关系

**** 各种概念

***** 事务
      Hibernate的对任何数据有改动的操作，都应该被放在事务里面。在事务中的多个操作行为，要么都成功，要么都失败。

**** 注解

***** 注解手册
        类相关注解
            @Entity —— 将一个类声明为一个实体bean(即一个持久化POJO类)
            @Table —— 注解声明了该实体bean映射指定的表（table）,目录（catalog）和schema的名字

        属性相关注解
            @Id —— 注解声明了该实体bean的标识属性（对应表中的主键）。
            @Column —— 注解声明了属性到列的映射。该注解有如下的属性
                name 可选，列名（默认值是属性名）
                unique 可选，是否在该列上设置唯一约束（默认值false）
                nullable 可选，是否设置该列的值可以为空（默认值false）
                insertable 可选，该列是否作为生成的insert语句中的一个列（默认值true）
                updatable 可选，该列是否作为生成的update语句中的一个列（默认值true）
                columnDefinition 可选，为这个特定列覆盖sql ddl片段（这可能导致无法在不同数据库间移植）
                table 可选，定义对应的表（默认为主表）
                length 可选，列长度（默认值255）
                precision 可选，列十进制精度（decimal precision)(默认值0）
                scale 可选，如果列十进制数值范围（decimal scale）可用，在此设置（默认值0）
            @GeneratedValue —— 注解声明了主键的生成策略。该注解有如下属性
                strategy 指定生成的策略（JPA定义的），这是一个GenerationType。默认是GenerationType. AUTO
                GenerationType.AUTO 主键由程序控制
                GenerationType.TABLE 使用一个特定的数据库表格来保存主键
                GenerationType.IDENTITY 主键由数据库自动生成（主要是自动增长类型）
                GenerationType.SEQUENCE 根据底层数据库的序列来生成主键，条件是数据库支持序列。（这个值要与generator一起使用）
                generator 指定生成主键使用的生成器（可能是orcale中的序列）。
            @SequenceGenerator —— 注解声明了一个数据库序列。该注解有如下属性
                name 表示该表主键生成策略名称，它被引用在@GeneratedValue中设置的“gernerator”值中
                sequenceName 表示生成策略用到的数据库序列名称。
                initialValue 表示主键初始值，默认为0.
                allocationSize 每次主键值增加的大小，例如设置成1，则表示每次创建新记录后自动加1，默认为50.

        关系相关注解
            @ManyToOne 设置多对一关联
                方法一
                    @ManyToOne(cascade={CasCadeType.PERSIST,CascadeType.MERGE})
                    @JoinColumn(name="外键")
                    public 主表类 get主表类(){return 主表对象}
                方法二
                    @ManyToOne(cascade={CascadeType.PERSIST,CascadeType.MERGE})
                    @JoinTable(name="关联表名"，
                        joinColumns = @JoinColumn(name="主表外键"),
                        inverseJoinColumns = @JoinColumns(name="从表外键")
                    )
            @OneToMany 设置一对多关联。
                方法一 。
                    “一端”配置
                    @OneToMany(mappedBy="“多端”的属性")
                    public List<“多端”类> get“多端”列表(){return “多端”列表}
                    “多端”配置参考@ManyToOne.
                方法二
                    “一端”配置
                    @OneToMany(mappedBy="“多端”的属性")
                    @MapKey(name="“多端”做为Key的属性")
                    public Map<“多端”做为Key的属性的类,主表类> get“多端”列表（）{return “多端”列表}
                    “多端”配置参考@ManyToOne.
                方法三 使用这种配置，在为“一端”添加“多端”时，可以修改“多端”的外键。
                    “一端”配置
                    @OneToMany
                    @JoinColumn(name="“多端”外键")
                    public List<“多端”类> get“多端”列表(){return “多端”列表}
                    “多端”配置参考@ManyToOne.

***** 注解和 XML 的取舍
       那么到底该用注解，还是xml文件配置方式呢？ 他们各自有各自的优缺点：
       XML配置方式：
           优：容易编辑，配置比较集中，方便修改，在大业务量的系统里面，通过xml配置会方便后人理解整个系统的架构，修改之后直接重启应用即可
           缺：比较繁琐，配置形态丑陋, 配置文件过多的时候难以管理
       注解方式：
           优：方便，简洁，配置信息和 Java 代码放在一起，有助于增强程序的内聚性。
           缺：分散到各个class文件中，所以不宜维护, 修改之后你需要重新打包，发布，重启应用。

       个人体会： 小项目，参与人数不多，不复杂的用注解，开发快速。 复杂项目，多人交互，配置量大，维护复杂度高的，用配置文件。

*** SPRING

**** IOC/DI

***** 原理图
      传统的方式：通过new 关键字主动创建一个对象
      IOC方式：对象的生命周期由Spring来管理，直接从Spring那里去获取一个对象。 IOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。

      打个比喻：
      传统方式：相当于你自己去菜市场new 了一只鸡，但是是生鸡，要自己拔毛，去内脏，再上花椒，酱油，烤制，经过各种工序之后，才可以食用。
      用 IOC：相当于去馆子(Spring)点了一只鸡，交到你手上的时候，已经五味俱全，你就只管吃就行了。

**** AOP
     参考文章：http://blog.csdn.net/qq_22063697/article/details/51912386

**** 注解方式测试
     修改TestSpring, 并运行
     1. @RunWith(SpringJUnit4ClassRunner.class)
     表示这是一个Spring的测试类

     2. @ContextConfiguration("classpath:applicationContext.xml")
     定位Spring的配置文件

     3. @Autowired
     给这个测试类装配Category对象

     4. @Test
     测试逻辑，打印c对象的名称


     import com.how2java.pojo.Category;
     @RunWith(SpringJUnit4ClassRunner.class)
     @ContextConfiguration("classpath:applicationContext.xml")
     public class TestSpring {
         @Autowired
         Category c;

         @Test
         public void test(){
         System.out.println(c.getName());
         }
     }

*** Spring MVC
